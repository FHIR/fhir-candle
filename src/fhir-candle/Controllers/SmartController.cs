// <copyright file="SmartController.cs" company="Microsoft Corporation">
//     Copyright (c) Microsoft Corporation. All rights reserved.
//     Licensed under the MIT License (MIT). See LICENSE in the repo root for license information.
// </copyright>

using System.Net;
using fhir.candle.Models;
using fhir.candle.Services;
using Fhir.Metrics;
using FhirCandle.Storage;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Net.Http.Headers;

namespace fhir.candle.Controllers;

/// <summary>A FHIR API controller.</summary>
[ApiController]
[Route("_smart", Order = 1)]
[Produces("application/json")]
public class SmartController : ControllerBase
{
    private ISmartAuthManager _smartAuthManager;

    /// <summary>
    /// Initializes a new instance of the <see cref="FhirController"/> class.
    /// </summary>
    /// <exception cref="ArgumentNullException">Thrown when one or more required arguments are null.</exception>
    /// <param name="fhirStore">The FHIR store.</param>
    public SmartController(
        [FromServices] ISmartAuthManager smartAuthManager)
    {
        if (smartAuthManager == null)
        {
            throw new ArgumentNullException(nameof(smartAuthManager));
        }

        _smartAuthManager = smartAuthManager;
    }

    /// <summary>(An Action that handles HTTP GET requests) gets smart well known.</summary>
    /// <param name="store">The store.</param>
    /// <returns>An asynchronous result.</returns>
    [HttpGet, Route("{store}/.well-known/smart-configuration")]
    public async Task GetSmartWellKnown(
        [FromRoute] string store)
    {
        // make sure this store exists and has SMART enabled
        if (!_smartAuthManager.SmartConfigurationByTenant.TryGetValue(
                store,
                out FhirStore.Smart.SmartWellKnown? smartConfig))
        {
            Response.StatusCode = 404;
            return;
        }

        // SMART well-known configuration is always returned as JSON
        Response.ContentType = "application/json";
        Response.StatusCode = (int)HttpStatusCode.OK;

        await Response.WriteAsync(FhirCandle.Serialization.Utils.SerializeObject(smartConfig));
    }

    /// <summary>(An Action that handles HTTP GET requests) gets smart authorize.</summary>
    /// <param name="store">        The store.</param>
    /// <param name="responseType"> Fixed value: code.</param>
    /// <param name="clientId">     The client's identifier.</param>
    /// <param name="redirectUri">  Must match one of the client's pre-registered redirect URIs.</param>
    /// <param name="launch">       When using the EHR Launch flow, this must match the launch value
    ///  received from the EHR. Omitted when using the Standalone Launch.</param>
    /// <param name="scope">        Must describe the access that the app needs.</param>
    /// <param name="state">        An opaque value used by the client to maintain state between the
    ///  request and callback.</param>
    /// <param name="audience">     URL of the EHR resource server from which the app wishes to
    ///  retrieve FHIR data.</param>
    /// <param name="pkceChallenge">This parameter is generated by the app and used for the code
    ///  challenge, as specified by PKCE. (required v2, opt v1)</param>
    /// <param name="pkceMethod">   Method used for the code_challenge parameter. (required v2, opt v1)</param>
    /// <returns>An asynchronous result.</returns>
    [HttpGet, Route("{store}/authorize")]
    public void GetSmartAuthorize(
        [FromRoute] string store,
        [FromQuery(Name = "response_type")] string responseType,
        [FromQuery(Name = "client_id")] string clientId,
        [FromQuery(Name = "redirect_uri")] string redirectUri,
        [FromQuery(Name = "launch")] string? launch,
        [FromQuery(Name = "scope")] string scope,
        [FromQuery(Name = "state")] string state,
        [FromQuery(Name = "aud")] string audience,
        [FromQuery(Name = "code_challenge")] string? pkceChallenge,
        [FromQuery(Name = "code_challenge_method")] string? pkceMethod)
    {
        if (!_smartAuthManager.RequestAuth(
                store,
                Request.HttpContext.Connection.RemoteIpAddress?.ToString() ?? string.Empty,
                responseType,
                clientId,
                redirectUri,
                launch,
                scope,
                state,
                audience,
                pkceChallenge,
                pkceMethod,
                out string redirectDestination))
        {
            Response.StatusCode = 404;
            return;
        }

        Response.Redirect(redirectDestination);
    }
}
