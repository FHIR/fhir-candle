@using Microsoft.FluentUI.AspNetCore.Components;

@page "/smart/auth"

@inject NavigationManager NavigationManager
@inject IFhirStoreManager StoreManager
@inject ISmartAuthManager AuthManager

@implements IDisposable

<PageTitle>SMART Authorization</PageTitle>

<FluentStack Orientation="Orientation.Vertical" VerticalGap="8">

@if (string.IsNullOrEmpty(ErrorMessage))
{
    <FluentLabel Typo="Typography.H4">SMART Authorization</FluentLabel>
    <FluentLabel Typo="Typography.Body">Please select allowed scopes:</FluentLabel>

    <FluentStack Orientation="Orientation.Horizontal" Spacing="4">
        <FluentButton BackgroundColor="var(--success)" OnClick="@(() => ApproveAuth())">Approve Selected Scopes</FluentButton>
        <FluentButton BackgroundColor="var(--error)" OnClick="@(() => DenyAuth())">Cancel</FluentButton>
    </FluentStack>

    <FluentCheckbox Label="@($"All Scopes")"
                ThreeState="true"
                ShowIndeterminate="false"
                @bind-CheckState="AllScopesSelected" />

    @*
    @foreach (string scope in _auth.Scopes.Keys)
    {
        bool isChecked = _selected.Contains(scope);
        <FluentCheckbox Label="@($"{scope}")"
                        @bind-Value:get="isChecked"
                        @bind-Value:set="c => OnScopeApprovalChanged(scope, c)" />
    }
    *@

    <FluentDataGrid Items="@_items" GridTemplateColumns="2fr" RowClass="@(s => _selected.Contains(s) ? "highlighted-row" : null)" OnRowFocus="HandleRowFocus" TGridItem=string>

        <PropertyColumn Title="Scope" Property="@(t => t)" Sortable="true" Tooltip="true">
        </PropertyColumn>

    </FluentDataGrid>
}
else
{
    <FluentLabel Typo="Typography.H4">SMART Authorization</FluentLabel>
    <FluentLabel Typo="Typography.Body">Error</FluentLabel>
    <FluentLabel Typo="Typography.Body">@ErrorMessage</FluentLabel>
}

</FluentStack>


@code {
    /// <summary>Gets or sets the navigation tracker.</summary>
    [CascadingParameter]
    public INavTracker? NavTracker { get; set; } = null;

    private NavPageInfoRec[] _navPages => new NavPageInfoRec[]
    {
        new() { Display = "Authorization: " + StoreName, Link = $"/smart/auth?store={StoreName}&key={Key}" },
    };

    private IQueryable<string> _items = Array.Empty<string>().AsQueryable();

    /// <summary>The selected scopes.</summary>
    private readonly HashSet<string> _selected = new();

    /// <summary>Gets or sets all scopes selected.</summary>
    private bool? AllScopesSelected
    {
        get
        {
            return _selected.SetEquals(_auth.Scopes.Keys)
                ? true
                : _selected.Count == 0
                    ? false
                    : null;
        }
        set
        {
            if (value is true)
            {
                _selected.UnionWith(_auth.Scopes.Keys);
            }
            else if (value is false)
            {
                _selected.Clear();
            }
        }
    }

    /// <summary>Gets or sets the package name.</summary>
    [Parameter]
    [SupplyParameterFromQuery(Name = "store")]
    public string StoreName { get; set; } = "";

    /// <summary>Gets or sets the authorization key.</summary>
    [Parameter]
    [SupplyParameterFromQuery(Name = "key")]
    public string Key { get; set; } = string.Empty;

    public string ErrorMessage { get; set; } = string.Empty;

    /// <summary>The authorization information.</summary>
    private AuthorizationInfo _auth = null!;

    private void HandleRowFocus(FluentDataGridRow<string> row)
    {
        // _ = JsLogAsync($"Focused row item id: {row.Item?.Id}");

        if (row?.Item != null)
        {
            if (_selected.Contains(row.Item))
            {
                _selected.Remove(row.Item);
            }
            else
            {
                _selected.Add(row.Item);
            }
        }

        StateHasChanged();
    }

    /// <summary>Executes the initialized asynchronous action.</summary>
    /// <returns>An asynchronous result.</returns>
    protected override void OnInitialized()
    {
        base.OnInitialized();

        _ = AuthManager.TryGetAuthorization(StoreName, Key, out _auth);

        if (_auth != null)
        {
            _items = _auth.Scopes.Keys.AsQueryable();
            _selected.Clear();
            AllScopesSelected = true;
        }

        NavTracker?.NotifyNav(_navPages);
    }

    /// <summary>Executes the scope approval changed action.</summary>
    /// <param name="scope">    The scope.</param>
    /// <param name="isVisible">True if is visible, false if not.</param>
    protected void OnScopeApprovalChanged(string scope, bool isVisible)
    {
        if (isVisible)
        {
            _selected.Add(scope);
        }
        else
        {
            _selected.Remove(scope);
        }
    }

    private void DenyAuth()
    {
        if (AuthManager.TryGetClientRedirect(StoreName, Key, out string url, "denied", "authorization request was denied"))
        {
            NavigationManager.NavigateTo(url);
        }

        // TODO: show an error on the screen
    }

    private void ApproveAuth()
    {
        foreach (string scope in _auth.Scopes.Keys)
        {
            _auth.Scopes[scope] = _selected.Contains(scope);
        }

        _ = AuthManager.TryUpdateAuth(StoreName, Key, _auth);

        if (!AuthManager.TryGetClientRedirect(StoreName, Key, out string redirect))
        {
            ErrorMessage = "Failed to retrieve redirect URL for client.";
            return;
        }

        NavigationManager.NavigateTo(redirect);
    }

    /// <summary>Handles the location changed.</summary>
    /// <param name="sender">The sender.</param>
    /// <param name="e">     Location changed event information.</param>
    private void HandleLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        if (e.Location.ToLowerInvariant().Contains("/smart/auth?", StringComparison.Ordinal))
        {
            _ = AuthManager.TryGetAuthorization(StoreName, Key, out _auth);

            NavTracker?.NotifyNav(_navPages);
        }
    }

    /// <summary>
    /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged
    /// resources.
    /// </summary>
    public void Dispose()
    {
        // if (_store != null)
        // {
        // }
    }
}
